<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://thunkable.github.io/webviewer-extension/thunkableWebviewerExtension.js" type="text/javascript"></script>
  </head>

  <body>
    <h3>Thunkable ↔ JavaScript Bridge: Geo Test</h3>
    <p id="status">Waiting for coordinates...</p>

    <script type="text/javascript">
      const status = document.getElementById("status");

      // --- Point in Polygon function (Ray-casting algorithm) ---
      function pointInPolygon(point, polygon) {
        const [x, y] = point;
        let inside = false;

        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
          const xi = polygon[i][0], yi = polygon[i][1];
          const xj = polygon[j][0], yj = polygon[j][1];

          const intersect = ((yi > y) !== (yj > y)) &&
                            (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
          if (intersect) inside = !inside;
        }
        return inside;
      }

      // --- Main bridge handler ---
      ThunkableWebviewerExtension.receiveMessageWithReturnValue(async function(message, callback) {
        console.log("Received from Thunkable:", message);
        status.textContent = "Received message: " + JSON.stringify(message);

        // Handle test message
        if (message === "test") {
          setTimeout(() => {
            callback("loud and clear!");
            status.textContent = "✅ Responded: loud and clear!";
          }, 4000);
          return;
        }

        try {
          const data = typeof message === "string" ? JSON.parse(message) : message;

          if (data.lat && data.lon && data.geojson) {
            const point = [parseFloat(data.lon), parseFloat(data.lat)];
            const geo = typeof data.geojson === "string" ? JSON.parse(data.geojson) : data.geojson;

            let foundRegion = null;

            // Loop through each feature (region)
            for (const feature of geo.features) {
              const coords = feature.geometry.coordinates;

              if (feature.geometry.type === "Polygon") {
                if (pointInPolygon(point, coords[0])) {
                  foundRegion = feature.properties?.Name || "Unnamed Region";
                  break;
                }
              }

              if (feature.geometry.type === "MultiPolygon") {
                for (const poly of coords) {
                  if (pointInPolygon(point, poly[0])) {
                    foundRegion = feature.properties?.Name || "Unnamed Region";
                    break;
                  }
                }
              }

              if (foundRegion) break;
            }

            const result = foundRegion || "No region found";
            callback(result);
            status.textContent = `✅ Result: ${result}`;
            console.log("Result sent:", result);
            return;
          }

        } catch (err) {
          console.error("Error:", err);
          callback("error: " + err.message);
          status.textContent = "❌ Error: " + err.message;
          return;
        }

        // Fallback
        callback("unrecognized message");
      });
    </script>
  </body>
</html>
